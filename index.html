<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snake Game - Cursed Slithers</title>
    <style>
        /* --- Reset & Base Styles --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #e0e0e0;
        }

        /* --- Game Container & Layout --- */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #0f3460;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            position: relative;
            max-width: calc(100vw - 20px);
            width: auto;
        }

        .game-header {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .game-title {
            font-size: 24px;
            font-weight: bold;
            color: #e94560;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        /* --- Score Display --- */
        .score-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
            width: 100%;
        }

        .score-item {
            font-size: 13px;
            font-weight: bold;
            color: #fff;
            background-color: #1a1a2e;
            padding: 4px 8px;
            border-radius: 15px;
            white-space: nowrap;
            flex-grow: 1;
            text-align: center;
        }
        .score-item span {
            display: inline-block;
            min-width: 15px;
            text-align: right;
            margin-left: 4px;
        }

        .current-score span { color: #4ecca3; }
        .session-highscore span { color: #f9d56e; }
        .lifetime-highscore span { color: #ff9e7d; }

        /* --- Canvas --- */
        #gameCanvas {
            border: 3px solid #e94560;
            border-radius: 5px;
            background-color: #1a1a2e;
            display: block;
            max-width: 100%;
            height: auto;
            width: 400px; /* Fixed size for game logic */
            height: 400px; /* Fixed size for game logic */
            margin-bottom: 5px; /* Add slight space before controls if they appear */
        }

        /* --- Overlays (Start & Game Over) --- */
        .overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            width: calc(100% - 30px);
            height: calc(100% - 30px);
            background-color: rgba(15, 52, 96, 0.85);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(3px);
            padding: 15px;
            text-align: center;
            box-sizing: border-box;
            overflow-y: auto;
        }

        #startScreen { display: flex; }
        #gameOverOverlay { display: none; }

        .overlay-content {
             background-color: rgba(22, 33, 62, 0.9);
             padding: 20px;
             border-radius: 10px;
             border: 2px solid #e94560;
             box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
             max-width: 95%;
             max-height: 90%;
             overflow-y: auto;
        }

        #startScreen h2 { color: #4ecca3; font-size: 24px; margin-bottom: 10px; }
        #gameOverOverlay h2 { color: #e94560; font-size: 28px; margin-bottom: 10px; }

         .overlay .snake-story {
            background-color: transparent;
            border-left: none;
            padding: 0;
            margin: 0 0 10px 0;
            text-align: left;
            font-size: 13px;
            line-height: 1.4;
            color: #c0c0c0;
         }
         .overlay .snake-story h3 {
             color: #f9d56e;
             font-size: 16px;
             margin-bottom: 6px;
             text-align: center;
         }
        .overlay .instructions {
            font-size: 13px;
            margin-top: 10px;
            color: #e0e0e0;
            line-height: 1.5;
        }
         .overlay .instructions strong {
             color: #f9d56e;
             font-weight: bold;
         }
         .start-instructions { /* Specific class for start instructions */
            margin-top: 15px !important;
         }


        /* --- Mobile Control Selection --- */
        #mobileControlSelection {
            display: none; /* Hidden by default, shown via JS for mobile */
            margin-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            padding-top: 15px;
        }
        #mobileControlSelection p {
            margin-bottom: 10px;
            font-size: 14px;
            color: #f9d56e;
        }
        .control-option-button {
            background-color: #16213e;
            border: 1px solid #4ecca3;
            color: #e0e0e0;
            padding: 8px 15px;
            font-size: 14px;
            margin: 0 5px 10px 5px; /* Added bottom margin */
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .control-option-button.active {
            background-color: #4ecca3;
            color: #1a1a2e;
            font-weight: bold;
        }
        @media (hover: hover) {
            .control-option-button:not(.active):hover {
                background-color: #1f2c4a;
            }
        }

        /* --- On-Screen Tap Controls (UPDATED STYLES) --- */
        #tapControls {
            /* display: none; /* Controlled by JS */
            width: 100%;
            max-width: 240px; /* Increased max-width */
            margin: 10px auto 0 auto; /* Centered margin */
            padding: 5px; /* Reduced padding slightly */
            /* background-color: rgba(15, 52, 96, 0.7); Removed background */
            border-radius: 10px;
            display: grid; /* Keep using Grid */
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, auto); /* Rows adjust to content */
            gap: 8px; /* Increased gap slightly */
            justify-items: center;
            align-items: center;
        }

        .tap-button {
            width: 65px;  /* Increased size */
            height: 65px; /* Increased size */
            background-color: #e94560; /* Uniform color */
            color: white;
            border: none;
            border-radius: 50%; /* Keep round */
            font-size: 30px; /* Increased arrow size */
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Slightly larger shadow */
            user-select: none;
            transition: background-color 0.1s ease, transform 0.05s ease; /* Added transform transition */
        }
        .tap-button:active {
            background-color: #ff647f; /* Keep active color */
            transform: scale(0.95); /* Add slight scale down on tap */
        }

        /* Correct Grid positioning for buttons */
        #tapUp { grid-column: 2; grid-row: 1; }
        #tapLeft { grid-column: 1; grid-row: 2; }
        /* Center space - can be left empty */
        /* #tapPlaceholder { grid-column: 2; grid-row: 2; } */
        #tapRight { grid-column: 3; grid-row: 2; }
        #tapDown { grid-column: 2; grid-row: 3; } /* Correct row */


        /* Final Score Styling */
        #finalScoreDisplay {
            margin-bottom: 15px;
            font-size: 18px;
            color: #fff;
        }
         #finalScoreDisplay span {
             color: #4ecca3;
             font-weight: bold;
             font-size: 20px;
         }

        /* --- Main Buttons (Start/Restart) --- */
        button.main-button { /* Style for Start/Restart */
            background-color: #e94560;
            border: none;
            color: white;
            padding: 12px 25px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin-top: 15px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.2s ease;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        button.main-button:disabled {
            background-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        @media (hover: hover) {
            button.main-button:not(:disabled):hover {
                background-color: #ff647f;
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            }
        }
        button.main-button:active:not(:disabled) {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Media query for smaller screens */
        @media (max-width: 480px) {
            .game-container {
                 padding: 10px;
                 width: calc(100vw - 20px);
            }
            /* Adjust canvas size if needed for very small screens */
            /* #gameCanvas { width: 300px; height: 300px; } */

            .game-title { font-size: 20px; }
            .score-item { font-size: 12px; padding: 3px 6px;}
            .overlay { padding: 10px; top: 10px; left: 10px; width: calc(100% - 20px); height: calc(100% - 20px); }
            .overlay-content { padding: 15px; }
             #startScreen h2 { font-size: 20px; }
             #gameOverOverlay h2 { font-size: 24px; }
             .overlay .snake-story { font-size: 12px; }
             .overlay .snake-story h3 { font-size: 14px; }
             .overlay .instructions { font-size: 12px; }
             #finalScoreDisplay { font-size: 16px; }
             #finalScoreDisplay span { font-size: 18px; }
             button.main-button { padding: 10px 20px; font-size: 14px; }
             .control-option-button { padding: 7px 13px; font-size: 13px; }

             /* Adjust tap controls for small screens */
             #tapControls {
                 max-width: 210px; /* Slightly smaller max-width */
                 gap: 6px; /* Slightly smaller gap */
                 margin-top: 8px; /* Reduce top margin */
             }
             .tap-button {
                 width: 55px; /* Slightly smaller buttons */
                 height: 55px;
                 font-size: 26px; /* Slightly smaller font */
             }
        }
         /* Ensure tap controls are hidden initially via JS/inline style if needed */
         /* The JS already handles this display logic */

    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">Cursed Slithers</h1>
            <div class="score-container">
                <div class="score-item current-score">Score: <span id="score">0</span></div>
                <div class="score-item session-highscore">Session Best: <span id="sessionHighscore">0</span></div>
                <div class="score-item lifetime-highscore">All-Time Best: <span id="lifetimeHighscore">0</span></div>
            </div>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>

        <!-- On-Screen Tap Controls (Initially Hidden, layout corrected) -->
        <div id="tapControls" style="display: none;"> 
            <button id="tapUp" class="tap-button">↑</button>
            <button id="tapLeft" class="tap-button">←</button>

            <button id="tapRight" class="tap-button">→</button>
            <button id="tapDown" class="tap-button">↓</button>
        </div>

        <!-- Start Screen Overlay -->
        <div id="startScreen" class="overlay">
            <div class="overlay-content">
                <h2>Welcome to Cursed Slithers!</h2>
                <div class="snake-story">
                    <h3>The Curse of the Hungry Snake</h3>
                     <p>Long ago, there lived a snake named Slithers who was always hungry. One day, he slithered into a forbidden garden and ate a magical fruit despite the warning signs.</p>
                     <p>The garden's keeper, an old wizard, appeared and cursed Slithers: "Like Pinocchio's nose grew with lies, your body shall grow with every bite you take!"</p>
                     <p>Now Slithers must navigate his ever-growing body while satisfying his endless hunger. Can you help him survive his curse?</p>
                </div>
                <p class="instructions">
                    Eat the green gems (<span style="color:#4ecca3; font-weight:bold;">●</span>) to score & grow.<br> {/* Made food symbol bolder */}
                    Avoid the walls and your own tail!
                </p>
                <p class="instructions desktop-instructions">
                    Use <strong>Arrow Keys</strong> / <strong>W/A/S/D</strong>.
                </p>
                <p class="instructions mobile-instructions" style="display: none;">
                    Use <strong>Swipe</strong> or <strong>Tap Controls</strong>.
                </p>

                <!-- Mobile Control Selection Area -->
                <div id="mobileControlSelection">
                    <p>Choose your controls:</p>
                    <button id="selectSwipe" class="control-option-button">Swipe</button>
                    <button id="selectTap" class="control-option-button">Tap Arrows</button>
                </div>

                <p class="instructions start-instructions">
                     <span class="desktop-start">Press <strong>Enter</strong> or click Start.</span>
                     <span class="mobile-start" style="display: none;">Select controls then click Start.</span>
                 </p>
                <button id="startButton" class="main-button">Start Game</button>
            </div>
        </div>

        <!-- Game Over Overlay -->
        <div id="gameOverOverlay" class="overlay">
            <div class="overlay-content">
                <h2>Game Over!</h2>
                <p id="finalScoreDisplay">Your Score: <span id="finalScore">0</span></p>
                <p class="instructions">Press <strong>Enter</strong> or click the button below.</p>
                <button id="restartButton" class="main-button">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const sessionHighscoreElement = document.getElementById('sessionHighscore');
        const lifetimeHighscoreElement = document.getElementById('lifetimeHighscore');
        const startScreen = document.getElementById('startScreen');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const startButton = document.getElementById('startButton');
        const mobileControlSelection = document.getElementById('mobileControlSelection');
        const selectSwipeButton = document.getElementById('selectSwipe');
        const selectTapButton = document.getElementById('selectTap');
        const tapControlsContainer = document.getElementById('tapControls'); // Tap controls container
        const tapUpButton = document.getElementById('tapUp');
        const tapDownButton = document.getElementById('tapDown');
        const tapLeftButton = document.getElementById('tapLeft');
        const tapRightButton = document.getElementById('tapRight');

        // --- Game Constants ---
        const gridSize = 20;
        const canvasSize = canvas.width; // Assumes square canvas
        const gridWidth = canvasSize / gridSize;
        const gridHeight = canvasSize / gridSize;
        const LIFETIME_HS_KEY = 'snakeLifetimeHighScore_v3';
        const MOBILE_CONTROL_PREF_KEY = 'snakeMobileControlPref_v1';

        // --- Game State Variables ---
        let snake;
        let food;
        let score;
        let direction;
        let nextDirection;
        let gameSpeed;
        let gameLoopTimeout;
        let isGameOver;
        let isGameStarted;
        let changingDirection;
        let isMobile = false;
        let mobileControlPreference = null; // 'swipe', 'tap'

        // --- High Score Variables ---
        let sessionHighScore = 0;
        let lifetimeHighScore = 0;

        // --- Speed Control ---
        const initialSpeed = 160; // Milliseconds per frame
        const speedDecrement = 4;  // How much to decrease delay per food item
        const minSpeed = 55;       // Fastest speed (minimum delay)

        // --- Touch Control Variables (for Swipe) ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 30; // Minimum pixels for a swipe gesture

        // --- Utility Functions ---
        function isMobileDevice() {
             let hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
             const hasCoarsePointer = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
             // Prioritize coarse pointer as a strong indicator of touch-primary devices
             return hasCoarsePointer || hasTouch;
        }

        // --- Initialization ---
        function initGame() {
            // Reset game state
            const startX = Math.floor(gridWidth / 4);
            const startY = Math.floor(gridHeight / 2);
            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];
            food = generateFoodLocation();
            score = 0;
            direction = 'right'; // Initial direction
            nextDirection = 'right'; // Buffer for next move
            gameSpeed = initialSpeed;
            isGameOver = false;
            isGameStarted = true;
            changingDirection = false; // Input lock per tick

            // Update UI
            scoreElement.textContent = score;
            startScreen.style.display = 'none';
            gameOverOverlay.style.display = 'none';

            // Show/Hide Tap Controls based on preference
            if (isMobile && mobileControlPreference === 'tap') {
                tapControlsContainer.style.display = 'grid'; // Use grid display
            } else {
                tapControlsContainer.style.display = 'none';
            }

            // Clear previous game loop timeout if any
            if (gameLoopTimeout) clearTimeout(gameLoopTimeout);
            updateHighScoreDisplay(); // Ensure scores are current
            mainLoop(); // Start the game loop
        }

        // --- Game Loop ---
        function mainLoop() {
            if (isGameOver) {
                showGameOver(); // End loop and show overlay if game over
                return;
            }

            changingDirection = false; // Reset input lock for this tick

            // Schedule the next frame
            gameLoopTimeout = setTimeout(() => {
                clearCanvas();         // Clear previous frame
                updateDirection();     // Process buffered input
                moveSnake();           // Move snake & check collisions/food
                if (isGameOver) {      // Check again after moving
                    showGameOver();
                    return;
                }
                // checkFoodCollision(); // Now handled within moveSnake
                draw();                // Draw current game state
                mainLoop();            // Schedule next iteration
            }, gameSpeed);
        }

        // --- Drawing Functions ---
        function clearCanvas() {
            ctx.fillStyle = '#1a1a2e'; // Background color matching theme
            ctx.fillRect(0, 0, canvasSize, canvasSize);
        }

        function draw() {
            // Draw snake segments
            snake.forEach((segment, index) => {
                const pixelX = segment.x * gridSize;
                const pixelY = segment.y * gridSize;
                let segmentColor;

                if (index === 0) {
                    segmentColor = '#e94560'; // Head color
                } else {
                    // Fading green effect for body
                    const greenValue = Math.max(60, 200 - (index * 8));
                    segmentColor = `rgb(78, ${greenValue}, 163)`;
                }
                ctx.fillStyle = segmentColor;
                roundRect(ctx, pixelX + 1, pixelY + 1, gridSize - 2, gridSize - 2, 5, true); // Slightly inset

                // Draw eyes on the head segment
                if (index === 0) {
                    drawEyes(pixelX, pixelY);
                }
            });

            // Draw food
            ctx.fillStyle = '#4ecca3'; // Food color
            const foodRadius = gridSize / 2 - 2;
            const foodCenterX = food.x * gridSize + gridSize / 2;
            const foodCenterY = food.y * gridSize + gridSize / 2;
            roundRect(ctx, food.x * gridSize + 2, food.y * gridSize + 2, gridSize - 4, gridSize - 4, 3, true); // Rounded square food

            // Simple shine effect on food
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(foodCenterX - foodRadius / 3, foodCenterY - foodRadius / 3, foodRadius / 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEyes(pixelX, pixelY) {
             ctx.fillStyle = 'white'; // Eye background
             const eyeSize = gridSize / 5;
             const pupilSize = gridSize / 8;
             const eyeOffsetX = gridSize / 4;
             const eyeOffsetY = gridSize / 4;

             let eye1X, eye1Y, eye2X, eye2Y;
             let pupil1OffsetX = 0, pupil1OffsetY = 0, pupil2OffsetX = 0, pupil2OffsetY = 0;

             // Position eyes based on snake direction
             switch (direction) {
                 case 'up':
                     eye1X = pixelX + eyeOffsetX; eye1Y = pixelY + eyeOffsetY;
                     eye2X = pixelX + gridSize - eyeOffsetX - eyeSize; eye2Y = pixelY + eyeOffsetY;
                     pupil1OffsetY = -pupilSize / 3; pupil2OffsetY = -pupilSize / 3; // Look up
                     break;
                 case 'down':
                     eye1X = pixelX + eyeOffsetX; eye1Y = pixelY + gridSize - eyeOffsetY - eyeSize;
                     eye2X = pixelX + gridSize - eyeOffsetX - eyeSize; eye2Y = pixelY + gridSize - eyeOffsetY - eyeSize;
                     pupil1OffsetY = pupilSize / 3; pupil2OffsetY = pupilSize / 3; // Look down
                     break;
                 case 'left':
                     eye1X = pixelX + eyeOffsetX; eye1Y = pixelY + eyeOffsetY;
                     eye2X = pixelX + eyeOffsetX; eye2Y = pixelY + gridSize - eyeOffsetY - eyeSize;
                     pupil1OffsetX = -pupilSize / 3; pupil2OffsetX = -pupilSize / 3; // Look left
                     break;
                 case 'right':
                 default:
                     eye1X = pixelX + gridSize - eyeOffsetX - eyeSize; eye1Y = pixelY + eyeOffsetY;
                     eye2X = pixelX + gridSize - eyeOffsetX - eyeSize; eye2Y = pixelY + gridSize - eyeOffsetY - eyeSize;
                     pupil1OffsetX = pupilSize / 3; pupil2OffsetX = pupilSize / 3; // Look right
                     break;
             }

             // Draw white part (sclera)
             ctx.beginPath(); ctx.arc(eye1X + eyeSize / 2, eye1Y + eyeSize / 2, eyeSize / 2, 0, Math.PI * 2); ctx.fill();
             ctx.beginPath(); ctx.arc(eye2X + eyeSize / 2, eye2Y + eyeSize / 2, eyeSize / 2, 0, Math.PI * 2); ctx.fill();

             // Draw black part (pupil)
             ctx.fillStyle = 'black';
             ctx.beginPath(); ctx.arc(eye1X + eyeSize / 2 + pupil1OffsetX, eye1Y + eyeSize / 2 + pupil1OffsetY, pupilSize / 2, 0, Math.PI * 2); ctx.fill();
             ctx.beginPath(); ctx.arc(eye2X + eyeSize / 2 + pupil2OffsetX, eye2Y + eyeSize / 2 + pupil2OffsetY, pupilSize / 2, 0, Math.PI * 2); ctx.fill();
        }

        // Helper for rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill) {
            if (typeof radius === 'undefined') radius = 5;
            radius = Math.min(radius, width / 2, height / 2);
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill(); else ctx.stroke();
        }

        // --- Movement and Logic ---
         function updateDirection() {
             // Applies the buffered `nextDirection` if it's valid (not opposite)
             const opposite = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
             if (nextDirection !== direction && nextDirection !== opposite[direction]) {
                 direction = nextDirection;
             }
             // `nextDirection` remains until changed by new input
         }

        function moveSnake() {
            const head = { x: snake[0].x, y: snake[0].y }; // Copy current head position

            // Calculate new head position based on current `direction`
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

             // Check for collisions (wall or self) with the *new* head position
             if (checkCollision(head)) {
                 isGameOver = true; // Set flag if collision detected
                 return; // Stop further processing for this tick
             }

            // No collision: Add the new head to the front of the snake array
            snake.unshift(head);

             // Check if the new head position is where the food is
             const ateFood = head.x === food.x && head.y === food.y;
             if (ateFood) {
                 score += 10;                 // Increase score
                 scoreElement.textContent = score; // Update display
                 food = generateFoodLocation(); // Place new food
                 increaseSpeed();             // Increase game speed
                 // Don't pop the tail - snake grows
             } else {
                 snake.pop(); // Remove the last segment (tail) if no food eaten
             }
        }

        function checkCollision(head) {
            // Wall collision check
            if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
                return true;
            }
            // Self collision check (iterate through body segments)
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false; // No collision
        }

        function generateFoodLocation() {
            let newFoodPos;
            let attempts = 0;
            const maxAttempts = gridWidth * gridHeight * 0.5; // Safety limit
            do {
                newFoodPos = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                attempts++;
                 // Keep trying if the location is on any part of the snake
            } while (isLocationOnSnake(newFoodPos) && attempts < maxAttempts);

            if(attempts >= maxAttempts) { // Extremely unlikely unless grid is nearly full
                console.warn("Could not find empty spot for food easily.");
                 // Fallback: find the first available spot (can be slow if grid is full)
                 for (let x = 0; x < gridWidth; x++) {
                    for (let y = 0; y < gridHeight; y++) {
                         if (!isLocationOnSnake({x, y})) return {x, y};
                    }
                 }
                 return {x: 0, y: 0}; // Absolute fallback
            }
            return newFoodPos;
        }

        function isLocationOnSnake(pos) {
            // Check if the given position matches any snake segment's position
            return snake.some(segment => segment.x === pos.x && segment.y === pos.y);
        }

        function increaseSpeed() {
            // Decrease the timeout delay, making the game faster
            if (gameSpeed > minSpeed) {
                gameSpeed = Math.max(minSpeed, gameSpeed - speedDecrement);
            }
        }

        // --- Input Handling ---

        // Helper to attempt setting the next direction
        function trySetDirection(newDirection) {
             // Ignore input if game isn't running or if a direction change is already locked for this tick
            if (!isGameStarted || isGameOver || changingDirection) {
                return false;
            }

            const opposite = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };

             // Allow change only if it's not the current direction AND not the opposite direction
             // Prevents reversing direction into self and redundant inputs
            if (newDirection !== direction && newDirection !== opposite[direction]) {
                nextDirection = newDirection; // Buffer the new direction
                changingDirection = true;   // Lock input for this tick
                return true; // Input accepted
            }
            return false; // Input ignored (same or opposite direction)
        }

        // Keyboard Input
        function handleKeyPress(event) {
            const key = event.key;

            // Start/Restart Game with Enter key
            if (key === 'Enter') {
                 // Allow Enter for restart on game over screen
                 // Allow Enter for initial start ONLY if NOT mobile (mobile uses button)
                 if (gameOverOverlay.style.display === 'flex' || (!isGameStarted && !isMobile)) {
                    event.preventDefault(); // Prevent default browser action (like form submit)
                    initGame(); // Start or restart the game
                    return;
                 }
            }

            // Directional Input during gameplay (Arrows or WASD)
            if (isGameStarted && !isGameOver) {
                let directionAttempted = null;
                if (key === 'ArrowUp' || key.toLowerCase() === 'w') directionAttempted = 'up';
                else if (key === 'ArrowDown' || key.toLowerCase() === 's') directionAttempted = 'down';
                else if (key === 'ArrowLeft' || key.toLowerCase() === 'a') directionAttempted = 'left';
                else if (key === 'ArrowRight' || key.toLowerCase() === 'd') directionAttempted = 'right';

                if (directionAttempted) {
                    // Try setting the direction and prevent default page scroll if successful
                    if(trySetDirection(directionAttempted)) {
                        event.preventDefault();
                    }
                }
            }
        }

        // --- Touch Input Handling (Swipe) ---
        function handleTouchStart(event) {
            // Only process swipes if game is active AND swipe controls are selected
            if (isGameStarted && !isGameOver && isMobile && mobileControlPreference === 'swipe') {
                const firstTouch = event.touches[0];
                touchStartX = firstTouch.clientX;
                touchStartY = firstTouch.clientY;
                touchEndX = touchStartX; // Initialize end points
                touchEndY = touchStartY;
            } else {
                touchStartX = 0; touchStartY = 0; // Reset if not applicable
            }
        }

        function handleTouchMove(event) {
             // Prevent scrolling DURING a swipe only if swipe is active, game running, and swipe started
             if (isGameStarted && !isGameOver && isMobile && mobileControlPreference === 'swipe' && touchStartX !== 0) {
                 // Check if the touch target is the canvas or tap controls to be more specific?
                 // For now, prevent scroll broadly during active swipe.
                 event.preventDefault();
                 const touch = event.touches[0];
                 touchEndX = touch.clientX;
                 touchEndY = touch.clientY;
             }
        }

        function handleTouchEnd(event) {
            // Process swipe end only if applicable
            if (isGameStarted && !isGameOver && isMobile && mobileControlPreference === 'swipe' && touchStartX !== 0) {
                 // Use changedTouches for the final position of the finger that lifted
                 const touch = event.changedTouches[0];
                 touchEndX = touch.clientX;
                 touchEndY = touch.clientY;

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;

                // Check if swipe distance is significant enough
                if (Math.abs(deltaX) > minSwipeDistance || Math.abs(deltaY) > minSwipeDistance) {
                    // Determine dominant direction (horizontal vs vertical)
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        trySetDirection(deltaX > 0 ? 'right' : 'left');
                    } else {
                        trySetDirection(deltaY > 0 ? 'down' : 'up'); // Y increases downwards
                    }
                }
                // Reset coordinates for the next potential swipe
                touchStartX = 0;
                touchStartY = 0;
            }
        }

        // --- Tap Control Button Handling ---
        function handleTapButtonClick(event) {
            if (!isGameStarted || isGameOver) return; // Ignore taps if game not running

            const buttonId = event.currentTarget.id;
            let directionAttempted = null;

            switch (buttonId) {
                case 'tapUp': directionAttempted = 'up'; break;
                case 'tapDown': directionAttempted = 'down'; break;
                case 'tapLeft': directionAttempted = 'left'; break;
                case 'tapRight': directionAttempted = 'right'; break;
            }

            if (directionAttempted) {
                trySetDirection(directionAttempted); // Attempt to set the direction
            }
        }

        // --- High Score Logic ---
        function loadHighScores() {
            const storedLifetimeScore = localStorage.getItem(LIFETIME_HS_KEY);
            lifetimeHighScore = storedLifetimeScore ? parseInt(storedLifetimeScore, 10) : 0;
            sessionHighScore = 0; // Reset session score on load
            updateHighScoreDisplay();
        }

        function updateHighScoreDisplay() {
            sessionHighscoreElement.textContent = sessionHighScore;
            lifetimeHighscoreElement.textContent = lifetimeHighScore;
        }

        function saveLifetimeHighScore() {
            localStorage.setItem(LIFETIME_HS_KEY, lifetimeHighScore.toString());
        }

        // --- Game Over ---
        function showGameOver() {
            clearTimeout(gameLoopTimeout); // Stop game loop
            isGameOver = true;
            isGameStarted = false;

            tapControlsContainer.style.display = 'none'; // Hide tap controls on game over

            // Update and save high scores
            if (score > sessionHighScore) sessionHighScore = score;
            if (score > lifetimeHighScore) {
                lifetimeHighScore = score;
                saveLifetimeHighScore();
            }

            // Update UI for game over
            updateHighScoreDisplay();
            finalScoreElement.textContent = score;
            gameOverOverlay.style.display = 'flex';
        }

        // --- Mobile Control Preference Logic ---
        function loadMobilePreference() {
             const pref = localStorage.getItem(MOBILE_CONTROL_PREF_KEY);
             if (pref === 'swipe' || pref === 'tap') {
                 mobileControlPreference = pref;
                 return true; // Preference loaded
             }
             return false; // No preference found or invalid
        }

        function saveMobilePreference(pref) {
             if (pref === 'swipe' || pref === 'tap') {
                 mobileControlPreference = pref;
                 localStorage.setItem(MOBILE_CONTROL_PREF_KEY, pref);
             }
        }

        function setupMobileControls() {
            // Show mobile-specific UI elements
            mobileControlSelection.style.display = 'block';
            document.querySelector('.desktop-instructions').style.display = 'none';
            document.querySelector('.mobile-instructions').style.display = 'inline';
            document.querySelector('.desktop-start').style.display = 'none';
            document.querySelector('.mobile-start').style.display = 'inline';

            const hasPreference = loadMobilePreference(); // Load saved pref

            if (hasPreference) {
                // Set button active state based on loaded preference
                if (mobileControlPreference === 'swipe') {
                    selectSwipeButton.classList.add('active');
                    selectTapButton.classList.remove('active');
                } else {
                    selectTapButton.classList.add('active');
                    selectSwipeButton.classList.remove('active');
                }
                startButton.disabled = false; // Enable start button immediately
            } else {
                 startButton.disabled = true; // Require selection before starting
            }

            // Add listeners to selection buttons
            selectSwipeButton.addEventListener('click', () => {
                saveMobilePreference('swipe');
                selectSwipeButton.classList.add('active');
                selectTapButton.classList.remove('active');
                startButton.disabled = false; // Enable start button
            });

            selectTapButton.addEventListener('click', () => {
                saveMobilePreference('tap');
                selectTapButton.classList.add('active');
                selectSwipeButton.classList.remove('active');
                startButton.disabled = false; // Enable start button
            });
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', handleKeyPress);
        startButton.addEventListener('click', initGame);
        restartButton.addEventListener('click', initGame);

        // Touch listeners for SWIPE controls
        // Passive: true where possible to improve scroll performance if default isn't prevented
        document.addEventListener('touchstart', handleTouchStart, { passive: true });
        document.addEventListener('touchmove', handleTouchMove, { passive: false }); // Need false because we call preventDefault
        document.addEventListener('touchend', handleTouchEnd, { passive: true });

         // Listeners for TAP control buttons
         tapUpButton.addEventListener('click', handleTapButtonClick);
         tapDownButton.addEventListener('click', handleTapButtonClick);
         tapLeftButton.addEventListener('click', handleTapButtonClick);
         tapRightButton.addEventListener('click', handleTapButtonClick);


        // --- Initial Setup on Page Load ---
        window.onload = () => {
            isGameStarted = false;
            isGameOver = false;
            isMobile = isMobileDevice(); // Check if mobile

            loadHighScores(); // Always load scores

            if (isMobile) {
                setupMobileControls(); // Show mobile control selection
            } else {
                // Desktop setup: Hide mobile things, show desktop text, enable start
                mobileControlSelection.style.display = 'none';
                document.querySelector('.mobile-instructions').style.display = 'none';
                document.querySelector('.mobile-start').style.display = 'none';
                document.querySelector('.desktop-instructions').style.display = 'block';
                document.querySelector('.desktop-start').style.display = 'inline';
                startButton.disabled = false;
            }

            // Initial UI state
            startScreen.style.display = 'flex';
            gameOverOverlay.style.display = 'none';
            tapControlsContainer.style.display = 'none'; // Ensure tap controls hidden at start
            clearCanvas(); // Draw initial background
        };

    </script>
</body>
</html>
