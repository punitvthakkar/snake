<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> 
    <title>Snake Game - Cursed Slithers</title>
    <style>
        /* --- Reset & Base Styles --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Improve touch interaction smoothness */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* Prevents double-tap zoom, etc. */
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent scrollbars absolutely */
        }

        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Adjust height for mobile browsers potentially showing address bar */
            min-height: 100vh;
            min-height: -webkit-fill-available; /* Safari */
            background: linear-gradient(135deg, #1a1a2e, #16213e); /* Dark space blue gradient */
            color: #e0e0e0; /* Light grey text */
        }

        /* --- Game Container & Layout --- */
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #0f3460; /* Dark blue container */
            border-radius: 10px;
            padding: 15px; /* Slightly reduced padding */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            position: relative; /* Needed for overlay positioning */
            /* Responsive width: canvas width + padding + border */
            /* Let canvas define the minimum width essentially */
            max-width: calc(100vw - 20px); /* Max width less some margin */
            width: auto; /* Allow shrinking */
        }

        .game-header {
            width: 100%;
            display: flex;
            flex-direction: column; /* Stack title and scores vertically on smaller screens */
            align-items: center;
            margin-bottom: 10px; /* Reduced margin */
            gap: 10px; /* Space between title and scores */
        }

        .game-title {
            font-size: 24px; /* Slightly smaller */
            font-weight: bold;
            color: #e94560; /* Bright pink/red */
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        /* --- Score Display --- */
        .score-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping if needed */
            justify-content: center; /* Center items */
            gap: 5px;
            width: 100%; /* Take full width */
        }

        .score-item {
            font-size: 13px; /* Smaller font */
            font-weight: bold;
            color: #fff;
            background-color: #1a1a2e; /* Dark background for score boxes */
            padding: 4px 8px; /* Adjusted padding */
            border-radius: 15px;
            text-align: right;
            /* min-width: 110px; */ /* Remove fixed min-width */
            white-space: nowrap; /* Prevent wrapping */
            flex-grow: 1; /* Allow items to grow */
            text-align: center; /* Center text */
        }
        .score-item span {
            display: inline-block;
            min-width: 15px; /* Space for score number */
            text-align: right;
            margin-left: 4px; /* Space between label and number */
        }

        .current-score span { color: #4ecca3; } /* Green current score number */
        .session-highscore span { color: #f9d56e; } /* Yellow session score number */
        .lifetime-highscore span { color: #ff9e7d; } /* Orange lifetime score number */

        /* --- Canvas --- */
        #gameCanvas {
            border: 3px solid #e94560; /* Slightly thinner border */
            border-radius: 5px;
            background-color: #1a1a2e; /* Dark canvas background */
            display: block; /* Prevent extra space */
             /* Make canvas responsive within limits */
            max-width: 100%;
            height: auto; /* Maintain aspect ratio */
            /* Fixed size needed for game logic - adjust if needed */
            width: 400px;
            height: 400px;
        }

        /* --- Overlays (Start & Game Over) --- */
        .overlay {
            position: absolute;
            /* Adjust positioning to account for container padding */
            top: 15px;
            left: 15px;
            width: calc(100% - 30px);
            height: calc(100% - 30px);
            background-color: rgba(15, 52, 96, 0.85);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            backdrop-filter: blur(3px);
            padding: 15px; /* Consistent padding */
            text-align: center;
            box-sizing: border-box;
            overflow-y: auto; /* Allow scrolling if content overflows */
        }

        #startScreen { display: flex; } /* Start screen visible initially */
        #gameOverOverlay { display: none; } /* Game over hidden initially */

        .overlay-content {
             background-color: rgba(22, 33, 62, 0.9);
             padding: 20px; /* Slightly less padding */
             border-radius: 10px;
             border: 2px solid #e94560;
             box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
             max-width: 95%; /* Ensure it fits well */
             max-height: 90%; /* Prevent vertical overflow */
             overflow-y: auto; /* Scroll if needed */
        }

         /* Specific title styling */
        #startScreen h2 { color: #4ecca3; font-size: 24px; margin-bottom: 10px; }
        #gameOverOverlay h2 { color: #e94560; font-size: 28px; margin-bottom: 10px; }

        /* Story & Instructions Styling */
         .overlay .snake-story {
            background-color: transparent;
            border-left: none;
            padding: 0;
            margin: 0 0 10px 0;
            text-align: left;
            font-size: 13px; /* Smaller font */
            line-height: 1.4;
            color: #c0c0c0;
         }
         .overlay .snake-story h3 {
             color: #f9d56e;
             font-size: 16px; /* Smaller */
             margin-bottom: 6px;
             text-align: center;
         }
        .overlay .instructions {
            font-size: 13px; /* Smaller */
            margin-top: 10px;
            color: #e0e0e0;
            line-height: 1.5;
        }
         .overlay .instructions strong {
             color: #f9d56e;
             font-weight: bold;
         }

        /* Final Score Styling */
        #finalScoreDisplay {
            margin-bottom: 15px;
            font-size: 18px; /* Smaller */
            color: #fff;
        }
         #finalScoreDisplay span {
             color: #4ecca3;
             font-weight: bold;
             font-size: 20px; /* Smaller */
         }

        /* --- Buttons --- */
        button {
            background-color: #e94560;
            border: none;
            color: white;
            padding: 12px 25px; /* Slightly larger for touch */
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin-top: 15px;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.2s ease; /* Faster transition */
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        /* Remove hover effect for touch devices where it's less relevant */
        @media (hover: hover) {
            button:hover {
                background-color: #ff647f;
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            }
        }
        button:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Media query for smaller screens */
        @media (max-width: 480px) {
            .game-container {
                 padding: 10px;
                 /* Ensure canvas fits */
                 width: calc(100vw - 20px);
            }
            
            .game-title { font-size: 20px; }
            .score-item { font-size: 12px; padding: 3px 6px;}
            .overlay { padding: 10px; top: 10px; left: 10px; width: calc(100% - 20px); height: calc(100% - 20px); }
            .overlay-content { padding: 15px; }
             #startScreen h2 { font-size: 20px; }
             #gameOverOverlay h2 { font-size: 24px; }
             .overlay .snake-story { font-size: 12px; }
             .overlay .snake-story h3 { font-size: 14px; }
             .overlay .instructions { font-size: 12px; }
             #finalScoreDisplay { font-size: 16px; }
             #finalScoreDisplay span { font-size: 18px; }
             button { padding: 10px 20px; font-size: 14px; }
        }

    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">Cursed Slithers</h1>
            <div class="score-container">
                <div class="score-item current-score">Score: <span id="score">0</span></div>
                <div class="score-item session-highscore">Session Best: <span id="sessionHighscore">0</span></div>
                <div class="score-item lifetime-highscore">All-Time Best: <span id="lifetimeHighscore">0</span></div>
            </div>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>

        <div id="startScreen" class="overlay">
            <div class="overlay-content">
                <h2>Welcome to Cursed Slithers!</h2>
                <div class="snake-story">
                    <h3>The Curse of the Hungry Snake</h3>
                    <p>Long ago, there lived a snake named Slithers who was always hungry. One day, he slithered into a forbidden garden and ate a magical fruit despite the warning signs.</p>
                    <p>The garden's keeper, an old wizard, appeared and cursed Slithers: "Like Pinocchio's nose grew with lies, your body shall grow with every bite you take!"</p>
                    <p>Now Slithers must navigate his ever-growing body while satisfying his endless hunger. Can you help him survive his curse?</p>
                </div>
                <p class="instructions">
                    Use <strong>Arrow Keys</strong> / <strong>W/A/S/D</strong><br>
                    or <strong>Swipe</strong> Up/Down/Left/Right.<br> {/* Added Swipe info */}
                    Eat the green gems (💎) to score & grow.<br>
                    Avoid the walls and your own tail!
                </p>
                <p class="instructions" style="margin-top: 20px;">Press <strong>Enter</strong> or <strong>Tap Screen</strong> to Start!</p> {/* Added Tap info */}
            </div>
        </div>

        <div id="gameOverOverlay" class="overlay">
            <div class="overlay-content">
                <h2>Game Over!</h2>
                <p id="finalScoreDisplay">Your Score: <span id="finalScore">0</span></p>
                <p class="instructions">Press <strong>Enter</strong> or click the button below.</p>
                <button id="restartButton">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const sessionHighscoreElement = document.getElementById('sessionHighscore');
        const lifetimeHighscoreElement = document.getElementById('lifetimeHighscore');
        const startScreen = document.getElementById('startScreen');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreElement = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');

        // --- Game Constants ---
        const gridSize = 20;
        // IMPORTANT: Ensure these match the canvas HTML attributes if changed
        const canvasSize = canvas.width;
        const gridWidth = canvasSize / gridSize;
        const gridHeight = canvasSize / gridSize;
        const LIFETIME_HS_KEY = 'snakeLifetimeHighScore_v2';

        // --- Game State Variables ---
        let snake;
        let food;
        let score;
        let direction;
        let nextDirection;
        let gameSpeed;
        let gameLoopTimeout;
        let isGameOver;
        let isGameStarted;
        let changingDirection; // Lock to prevent multiple direction changes per tick

        // --- High Score Variables ---
        let sessionHighScore = 0;
        let lifetimeHighScore = 0;

        // --- Speed Control ---
        const initialSpeed = 160;
        const speedDecrement = 4;
        const minSpeed = 55;

        // --- Touch Control Variables ---
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 30; // Minimum distance in pixels for a swipe

        // --- Initialization ---
        function initGame() {
            const startX = Math.floor(gridWidth / 4);
            const startY = Math.floor(gridHeight / 2);
            snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];

            food = generateFoodLocation();
            score = 0;
            direction = 'right';
            nextDirection = 'right';
            gameSpeed = initialSpeed;
            isGameOver = false;
            isGameStarted = true;
            changingDirection = false;

            scoreElement.textContent = score;
            startScreen.style.display = 'none';
            gameOverOverlay.style.display = 'none';

            if (gameLoopTimeout) clearTimeout(gameLoopTimeout);
            updateHighScoreDisplay();
            mainLoop();
        }

        // --- Game Loop ---
        function mainLoop() {
            if (isGameOver) {
                showGameOver();
                return;
            }

            changingDirection = false;

            gameLoopTimeout = setTimeout(() => {
                clearCanvas();
                updateDirection();
                moveSnake();
                if (isGameOver) {
                    showGameOver();
                    return;
                }
                checkFoodCollision();
                draw();
                mainLoop();
            }, gameSpeed);
        }

        // --- Drawing Functions ---
        function clearCanvas() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvasSize, canvasSize);
        }

        function draw() {
            // Draw snake
            snake.forEach((segment, index) => {
                const pixelX = segment.x * gridSize;
                const pixelY = segment.y * gridSize;

                if (index === 0) {
                    ctx.fillStyle = '#e94560'; // Red head
                } else {
                    const greenValue = Math.max(60, 200 - (index * 10));
                    ctx.fillStyle = `rgb(78, ${greenValue}, 163)`; // Greenish-blue body
                }
                roundRect(ctx, pixelX, pixelY, gridSize - 1, gridSize - 1, 5, true);

                if (index === 0) {
                    drawEyes(segment, pixelX, pixelY);
                }
            });

            // Draw food
            ctx.fillStyle = '#4ecca3'; // Green for food
            ctx.beginPath();
            const centerX = food.x * gridSize + gridSize / 2;
            const centerY = food.y * gridSize + gridSize / 2;
            const radius = gridSize / 2 - 2;
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(centerX - radius / 3, centerY - radius / 3, radius / 3.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEyes(segment, pixelX, pixelY) {
             ctx.fillStyle = 'white';
             const eyeSize = gridSize / 6;
             const eyeOffset = gridSize / 4;

             let eye1X, eye1Y, eye2X, eye2Y;

             switch (direction) {
                case 'up':
                    eye1X = pixelX + eyeOffset;
                    eye1Y = pixelY + eyeOffset;
                    eye2X = pixelX + gridSize - eyeOffset - eyeSize*2;
                    eye2Y = pixelY + eyeOffset;
                    break;
                case 'down':
                    eye1X = pixelX + eyeOffset;
                    eye1Y = pixelY + gridSize - eyeOffset - eyeSize*2;
                    eye2X = pixelX + gridSize - eyeOffset - eyeSize*2;
                    eye2Y = pixelY + gridSize - eyeOffset - eyeSize*2;
                    break;
                case 'left':
                    eye1X = pixelX + eyeOffset;
                    eye1Y = pixelY + eyeOffset;
                    eye2X = pixelX + eyeOffset;
                    eye2Y = pixelY + gridSize - eyeOffset - eyeSize*2;
                    break;
                case 'right':
                    eye1X = pixelX + gridSize - eyeOffset - eyeSize*2;
                    eye1Y = pixelY + eyeOffset;
                    eye2X = pixelX + gridSize - eyeOffset - eyeSize*2;
                    eye2Y = pixelY + gridSize - eyeOffset - eyeSize*2;
                    break;
             }

             roundRect(ctx, eye1X, eye1Y, eyeSize*2, eyeSize*2, eyeSize, true);
             roundRect(ctx, eye2X, eye2Y, eyeSize*2, eyeSize*2, eyeSize, true);

             ctx.fillStyle = 'black';
             roundRect(ctx, eye1X + eyeSize/2, eye1Y + eyeSize/2, eyeSize, eyeSize, eyeSize/2, true);
             roundRect(ctx, eye2X + eyeSize/2, eye2Y + eyeSize/2, eyeSize, eyeSize, eyeSize/2, true);
        }

        function roundRect(ctx, x, y, width, height, radius, fill) {
            if (typeof radius === 'undefined') radius = 5;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
            else ctx.stroke();
        }

        // --- Movement and Logic ---
         function updateDirection() {
             const opposite = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };
             if (direction !== opposite[nextDirection]) {
                 direction = nextDirection;
             }
         }

        function moveSnake() {
            const head = { x: snake[0].x, y: snake[0].y };

            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

             if (checkCollision(head)) {
                 isGameOver = true;
                 return;
             }

            snake.unshift(head);

             const ateFood = head.x === food.x && head.y === food.y;
             if (!ateFood) {
                 snake.pop();
             }
        }

        function checkCollision(head) {
            if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
                return true;
            }
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        function checkFoodCollision() {
             const head = snake[0];
             if (head.x === food.x && head.y === food.y) {
                 score += 10;
                 scoreElement.textContent = score;
                 food = generateFoodLocation();
                 increaseSpeed();
             }
         }

        function generateFoodLocation() {
            let newFoodPos;
            do {
                newFoodPos = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
            } while (isLocationOnSnake(newFoodPos));
            return newFoodPos;
        }

        function isLocationOnSnake(pos) {
            return snake.some(segment => segment.x === pos.x && segment.y === pos.y);
        }

        function increaseSpeed() {
            if (gameSpeed > minSpeed) {
                gameSpeed = Math.max(minSpeed, gameSpeed - speedDecrement);
            }
        }

        // --- Input Handling ---

        // Helper function to attempt setting the next direction
        function trySetDirection(newDirection) {
            if (!isGameStarted || isGameOver || changingDirection) {
                return; // Ignore input if game not running or already changing dir this tick
            }

            const opposite = { 'up': 'down', 'down': 'up', 'left': 'right', 'right': 'left' };

            // Allow change only if it's not the opposite direction
            if (direction !== opposite[newDirection]) {
                nextDirection = newDirection;
                changingDirection = true;
                return true; // Direction change was successful
            }
            return false; // Direction change was ignored (opposite)
        }

        function handleKeyPress(event) {
            const key = event.key;

            // Start/Restart Game with Enter
            if ((!isGameStarted || isGameOver) && key === 'Enter') {
                event.preventDefault();
                initGame();
                return;
            }

            let directionAttempted = null;
            if (key === 'ArrowUp' || key.toLowerCase() === 'w') directionAttempted = 'up';
            else if (key === 'ArrowDown' || key.toLowerCase() === 's') directionAttempted = 'down';
            else if (key === 'ArrowLeft' || key.toLowerCase() === 'a') directionAttempted = 'left';
            else if (key === 'ArrowRight' || key.toLowerCase() === 'd') directionAttempted = 'right';

            if (directionAttempted) {
                if(trySetDirection(directionAttempted)) {
                    event.preventDefault(); // Prevent scrolling only if direction changed
                }
            }
        }

        // --- Touch Input Handling ---
        function handleTouchStart(event) {
            // Only prevent default if game is active to allow scrolling on overlays
            if (isGameStarted && !isGameOver) {
                 // prevent browser handling like scrolling.
                 // Do this conditionally on touchstart/move during active game
                // event.preventDefault();
            }
            // Start game on tap if on start screen
            if (!isGameStarted && !isGameOver && startScreen.style.display !== 'none') {
                 initGame();
                 return; // Don't process as swipe if we just started the game
            }

            const firstTouch = event.touches[0];
            touchStartX = firstTouch.clientX;
            touchStartY = firstTouch.clientY;
            touchEndX = firstTouch.clientX; // Initialize end points
            touchEndY = firstTouch.clientY;
        }

        function handleTouchMove(event) {
             // Prevent scrolling/refresh DURING a swipe when game is active
             if (isGameStarted && !isGameOver) {
                 event.preventDefault();
             }
             // Update end points continuously for potential future use (e.g., drag controls)
             // For simple swipes, we only care about the final point in touchend
            const touch = event.touches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;
        }


        function handleTouchEnd(event) {
            // If game hasn't started or is over, do nothing for swipe detection
            if (!isGameStarted || isGameOver) {
                 // Reset points just in case
                 touchStartX = 0;
                 touchStartY = 0;
                 return;
            }

             // Use changedTouches to get the final position of the touch that ended
             const touch = event.changedTouches[0];
             touchEndX = touch.clientX;
             touchEndY = touch.clientY;

            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            // Check if it was more of a horizontal or vertical swipe
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > minSwipeDistance) {
                    if (deltaX > 0) {
                        trySetDirection('right');
                    } else {
                        trySetDirection('left');
                    }
                }
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > minSwipeDistance) {
                    if (deltaY > 0) {
                        trySetDirection('down'); // Y increases downwards
                    } else {
                        trySetDirection('up');
                    }
                }
            }

            // Reset coordinates for the next touch
            touchStartX = 0;
            touchStartY = 0;
            // No need to prevent default here usually, as the action is complete.
        }


        // --- High Score Logic ---
        function loadHighScores() {
            const storedLifetimeScore = localStorage.getItem(LIFETIME_HS_KEY);
            lifetimeHighScore = storedLifetimeScore ? parseInt(storedLifetimeScore, 10) : 0;
            sessionHighScore = 0;
            updateHighScoreDisplay();
        }

        function updateHighScoreDisplay() {
            sessionHighscoreElement.textContent = sessionHighScore;
            lifetimeHighscoreElement.textContent = lifetimeHighScore;
        }

        function saveLifetimeHighScore() {
            localStorage.setItem(LIFETIME_HS_KEY, lifetimeHighScore.toString());
        }

        // --- Game Over ---
        function showGameOver() {
            clearTimeout(gameLoopTimeout);
            isGameStarted = false; // Mark game as not running for input handlers
            // isGameOver is already true

            if (score > sessionHighScore) {
                sessionHighScore = score;
            }
            if (score > lifetimeHighScore) {
                lifetimeHighScore = score;
                saveLifetimeHighScore();
            }

            updateHighScoreDisplay();
            finalScoreElement.textContent = score;
            gameOverOverlay.style.display = 'flex';
        }

        // --- Event Listeners ---
        document.addEventListener('keydown', handleKeyPress);
        restartButton.addEventListener('click', initGame); // Works for touch taps too

        // Add touch event listeners to the document for global swipe detection
        document.addEventListener('touchstart', handleTouchStart, { passive: false }); // Need passive:false to call preventDefault if needed
        document.addEventListener('touchmove', handleTouchMove, { passive: false });   // Need passive:false to call preventDefault
        document.addEventListener('touchend', handleTouchEnd);


        // --- Initial Setup on Page Load ---
        window.onload = () => {
            isGameStarted = false;
            isGameOver = false;
            loadHighScores();
            startScreen.style.display = 'flex';
            gameOverOverlay.style.display = 'none';
            clearCanvas();
        };

    </script>
</body>
</html>